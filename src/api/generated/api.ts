/* tslint:disable */
/* eslint-disable */
/**
 * Beni Mono API
 * Comprehensive API documentation for Beni Mono backend
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'revokedAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKey
     */
    'isActive': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiKey
     */
    'ipWhitelist': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ApiKey
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'createdById': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @interface ApiUsageLog
 */
export interface ApiUsageLog {
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'method': string;
    /**
     * 
     * @type {number}
     * @memberof ApiUsageLog
     */
    'statusCode': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUsageLog
     */
    'responseTimeMs'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'ipAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'userAgent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'city'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiUsageLog
     */
    'isRateLimited': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'apiKeyId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'userId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'tenantId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsageLog
     */
    'apiKeyDirectId'?: string | null;
}
/**
 * 
 * @export
 * @interface ApikeyTenantIdApiKeysApiKeyIdPutRequest
 */
export interface ApikeyTenantIdApiKeysApiKeyIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApikeyTenantIdApiKeysApiKeyIdPutRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApikeyTenantIdApiKeysGet200Response
 */
export interface ApikeyTenantIdApiKeysGet200Response {
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ApikeyTenantIdApiKeysGet200Response
     */
    'apiKeys'?: Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface ApikeyTenantIdApiKeysPost201Response
 */
export interface ApikeyTenantIdApiKeysPost201Response {
    /**
     * 
     * @type {ApiKey}
     * @memberof ApikeyTenantIdApiKeysPost201Response
     */
    'apiKey'?: ApiKey;
}
/**
 * 
 * @export
 * @interface ApikeyTenantIdApiKeysPostRequest
 */
export interface ApikeyTenantIdApiKeysPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApikeyTenantIdApiKeysPostRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'tenantId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'actorId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'actorType': string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'target'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'ipAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'userAgent'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof AuditLog
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface AuthForgotPasswordPost200Response
 */
export interface AuthForgotPasswordPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthForgotPasswordPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthForgotPasswordPostRequest
 */
export interface AuthForgotPasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthForgotPasswordPostRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface AuthLoginPost200Response
 */
export interface AuthLoginPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost200Response
     */
    'token'?: string;
    /**
     * 
     * @type {AuthRegisterPost201ResponseUser}
     * @memberof AuthLoginPost200Response
     */
    'user'?: AuthRegisterPost201ResponseUser;
}
/**
 * 
 * @export
 * @interface AuthLoginPostRequest
 */
export interface AuthLoginPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface AuthLogoutPost200Response
 */
export interface AuthLogoutPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthLogoutPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthRegisterPost201Response
 */
export interface AuthRegisterPost201Response {
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost201Response
     */
    'message'?: string;
    /**
     * 
     * @type {AuthRegisterPost201ResponseUser}
     * @memberof AuthRegisterPost201Response
     */
    'user'?: AuthRegisterPost201ResponseUser;
}
/**
 * 
 * @export
 * @interface AuthRegisterPost201ResponseUser
 */
export interface AuthRegisterPost201ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost201ResponseUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost201ResponseUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost201ResponseUser
     */
    'fullName'?: string;
}
/**
 * 
 * @export
 * @interface AuthRegisterPostRequest
 */
export interface AuthRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface AuthRequestEmailVerificationPost200Response
 */
export interface AuthRequestEmailVerificationPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthRequestEmailVerificationPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthRequestMobileVerificationPost200Response
 */
export interface AuthRequestMobileVerificationPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthRequestMobileVerificationPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthRequestMobileVerificationPostRequest
 */
export interface AuthRequestMobileVerificationPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthRequestMobileVerificationPostRequest
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface AuthVerifyEmailPost200Response
 */
export interface AuthVerifyEmailPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthVerifyEmailPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthVerifyEmailPostRequest
 */
export interface AuthVerifyEmailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthVerifyEmailPostRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthVerifyEmailPostRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface AuthVerifyMobilePost200Response
 */
export interface AuthVerifyMobilePost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthVerifyMobilePost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthVerifyMobilePostRequest
 */
export interface AuthVerifyMobilePostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthVerifyMobilePostRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthVerifyMobilePostRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface AuthVerifyRegistrationPost200Response
 */
export interface AuthVerifyRegistrationPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthVerifyRegistrationPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'tenantId': string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'issuedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'paidAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'dueDate': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'referenceId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'gateway'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface LoginLog
 */
export interface LoginLog {
    /**
     * 
     * @type {string}
     * @memberof LoginLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LoginLog
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof LoginLog
     */
    'ipAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LoginLog
     */
    'userAgent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LoginLog
     */
    'status': LoginLogStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof LoginLog
     */
    'reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LoginLog
     */
    'createdAt': string;
}

export const LoginLogStatusEnum = {
    Success: 'SUCCESS',
    Failure: 'FAILURE'
} as const;

export type LoginLogStatusEnum = typeof LoginLogStatusEnum[keyof typeof LoginLogStatusEnum];

/**
 * 
 * @export
 * @interface LogsApiUsageGet200Response
 */
export interface LogsApiUsageGet200Response {
    /**
     * 
     * @type {Array<ApiUsageLog>}
     * @memberof LogsApiUsageGet200Response
     */
    'logs'?: Array<ApiUsageLog>;
}
/**
 * 
 * @export
 * @interface LogsAuditGet200Response
 */
export interface LogsAuditGet200Response {
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof LogsAuditGet200Response
     */
    'logs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface LogsLoginGet200Response
 */
export interface LogsLoginGet200Response {
    /**
     * 
     * @type {Array<LoginLog>}
     * @memberof LogsLoginGet200Response
     */
    'logs'?: Array<LoginLog>;
}
/**
 * 
 * @export
 * @interface Model2faEnablePost200Response
 */
export interface Model2faEnablePost200Response {
    /**
     * 
     * @type {string}
     * @memberof Model2faEnablePost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Model2faEnablePostRequest
 */
export interface Model2faEnablePostRequest {
    /**
     * 
     * @type {string}
     * @memberof Model2faEnablePostRequest
     */
    'method'?: string;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'status': PaymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'provider': PaymentProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'referenceId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'authorityCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'trackingCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'purpose': PaymentPurposeEnum;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'targetId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Payment
     */
    'isVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'verifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'failedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'updatedAt': string;
}

export const PaymentStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Canceled: 'CANCELED',
    Expired: 'EXPIRED'
} as const;

export type PaymentStatusEnum = typeof PaymentStatusEnum[keyof typeof PaymentStatusEnum];
export const PaymentProviderEnum = {
    Zarinpal: 'ZARINPAL',
    Idpay: 'IDPAY',
    Stripe: 'STRIPE',
    Paypal: 'PAYPAL',
    Manual: 'MANUAL'
} as const;

export type PaymentProviderEnum = typeof PaymentProviderEnum[keyof typeof PaymentProviderEnum];
export const PaymentPurposeEnum = {
    Subscription: 'SUBSCRIPTION',
    Product: 'PRODUCT',
    TripReservation: 'TRIP_RESERVATION',
    Donation: 'DONATION'
} as const;

export type PaymentPurposeEnum = typeof PaymentPurposeEnum[keyof typeof PaymentPurposeEnum];

/**
 * 
 * @export
 * @interface PaymentInitiatePost201Response
 */
export interface PaymentInitiatePost201Response {
    /**
     * 
     * @type {Payment}
     * @memberof PaymentInitiatePost201Response
     */
    'payment'?: Payment;
}
/**
 * 
 * @export
 * @interface PaymentInitiatePostRequest
 */
export interface PaymentInitiatePostRequest {
    /**
     * 
     * @type {number}
     * @memberof PaymentInitiatePostRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentInitiatePostRequest
     */
    'purpose'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentInitiatePostRequest
     */
    'targetId'?: string;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'resource': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'subCategory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'type': ProductTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'province': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'address'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'locationLat'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'locationLng'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'availableQty': number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'reservedQty': number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'discount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'finalPrice': number;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'isSuspended': boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'createdById': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'images'?: Array<string> | null;
}

export const ProductTypeEnum = {
    Hotel: 'HOTEL',
    Accommodation: 'ACCOMMODATION',
    Tour: 'TOUR',
    Activity: 'ACTIVITY',
    Other: 'OTHER'
} as const;

export type ProductTypeEnum = typeof ProductTypeEnum[keyof typeof ProductTypeEnum];

/**
 * 
 * @export
 * @interface ProductGet200Response
 */
export interface ProductGet200Response {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductGet200Response
     */
    'products'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductPost201Response
 */
export interface ProductPost201Response {
    /**
     * 
     * @type {Product}
     * @memberof ProductPost201Response
     */
    'product'?: Product;
}
/**
 * 
 * @export
 * @interface ProductPostRequest
 */
export interface ProductPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductPostRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPostRequest
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPostRequest
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPostRequest
     */
    'province'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPostRequest
     */
    'city'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductPostRequest
     */
    'price'?: number;
}
/**
 * 
 * @export
 * @interface ProductProductIdPutRequest
 */
export interface ProductProductIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductProductIdPutRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RbacRolesGet200Response
 */
export interface RbacRolesGet200Response {
    /**
     * 
     * @type {Array<Role>}
     * @memberof RbacRolesGet200Response
     */
    'roles'?: Array<Role>;
}
/**
 * 
 * @export
 * @interface RbacRolesPost201Response
 */
export interface RbacRolesPost201Response {
    /**
     * 
     * @type {Role}
     * @memberof RbacRolesPost201Response
     */
    'role'?: Role;
}
/**
 * 
 * @export
 * @interface RbacRolesPostRequest
 */
export interface RbacRolesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RbacRolesPostRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RbacRolesRoleIdPutRequest
 */
export interface RbacRolesRoleIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof RbacRolesRoleIdPutRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Reservation
 */
export interface Reservation {
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'productId': string;
    /**
     * 
     * @type {number}
     * @memberof Reservation
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'status': ReservationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'paymentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'paymentMethod'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'paymentStatus': ReservationPaymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'paidAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'cancelledAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'startDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'tripId'?: string | null;
}

export const ReservationStatusEnum = {
    Pending: 'PENDING',
    Paid: 'PAID',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Expired: 'EXPIRED',
    OnHold: 'ON_HOLD'
} as const;

export type ReservationStatusEnum = typeof ReservationStatusEnum[keyof typeof ReservationStatusEnum];
export const ReservationPaymentStatusEnum = {
    Paid: 'PAID',
    Unpaid: 'UNPAID',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Waiting: 'WAITING'
} as const;

export type ReservationPaymentStatusEnum = typeof ReservationPaymentStatusEnum[keyof typeof ReservationPaymentStatusEnum];

/**
 * 
 * @export
 * @interface ReservationGet200Response
 */
export interface ReservationGet200Response {
    /**
     * 
     * @type {Array<Reservation>}
     * @memberof ReservationGet200Response
     */
    'reservations'?: Array<Reservation>;
}
/**
 * 
 * @export
 * @interface ReservationPost201Response
 */
export interface ReservationPost201Response {
    /**
     * 
     * @type {Reservation}
     * @memberof ReservationPost201Response
     */
    'reservation'?: Reservation;
}
/**
 * 
 * @export
 * @interface ReservationPostRequest
 */
export interface ReservationPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ReservationPostRequest
     */
    'productId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ReservationPostRequest
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface ReservationReservationIdPutRequest
 */
export interface ReservationReservationIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ReservationReservationIdPutRequest
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Role
     */
    'isGlobal': boolean;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'ip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'userAgent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'lastActive': string;
}
/**
 * 
 * @export
 * @interface SessionsGet200Response
 */
export interface SessionsGet200Response {
    /**
     * 
     * @type {Array<Session>}
     * @memberof SessionsGet200Response
     */
    'sessions'?: Array<Session>;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'planId': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'startedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'expiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'status': SubscriptionStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    'renewalEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'paymentMethod'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'updatedAt': string;
}

export const SubscriptionStatusEnum = {
    Active: 'ACTIVE',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED'
} as const;

export type SubscriptionStatusEnum = typeof SubscriptionStatusEnum[keyof typeof SubscriptionStatusEnum];

/**
 * 
 * @export
 * @interface SubscriptionTenantIdInvoicesGet200Response
 */
export interface SubscriptionTenantIdInvoicesGet200Response {
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof SubscriptionTenantIdInvoicesGet200Response
     */
    'invoices'?: Array<Invoice>;
}
/**
 * 
 * @export
 * @interface SubscriptionTenantIdSubscriptionsGet200Response
 */
export interface SubscriptionTenantIdSubscriptionsGet200Response {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof SubscriptionTenantIdSubscriptionsGet200Response
     */
    'subscriptions'?: Array<Subscription>;
}
/**
 * 
 * @export
 * @interface SubscriptionTenantIdUsageGet200Response
 */
export interface SubscriptionTenantIdUsageGet200Response {
    /**
     * 
     * @type {Array<UsageRecord>}
     * @memberof SubscriptionTenantIdUsageGet200Response
     */
    'usage'?: Array<UsageRecord>;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Tenant
     */
    'id': string;
    /**
     * Tenant name
     * @type {string}
     * @memberof Tenant
     */
    'name': string;
    /**
     * Unique slug
     * @type {string}
     * @memberof Tenant
     */
    'slug': string;
    /**
     * URL to logo image
     * @type {string}
     * @memberof Tenant
     */
    'logoUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'contactPhone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'updatedAt'?: string;
    /**
     * ID of the owner user
     * @type {string}
     * @memberof Tenant
     */
    'ownerId': string;
}
/**
 * 
 * @export
 * @interface TenantGet200Response
 */
export interface TenantGet200Response {
    /**
     * 
     * @type {Array<Tenant>}
     * @memberof TenantGet200Response
     */
    'tenants'?: Array<Tenant>;
}
/**
 * 
 * @export
 * @interface TenantPost201Response
 */
export interface TenantPost201Response {
    /**
     * 
     * @type {Tenant}
     * @memberof TenantPost201Response
     */
    'tenant'?: Tenant;
}
/**
 * 
 * @export
 * @interface TenantPostRequest
 */
export interface TenantPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TenantPostRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TenantTenantIdPutRequest
 */
export interface TenantTenantIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof TenantTenantIdPutRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UsageRecord
 */
export interface UsageRecord {
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    'apiKeyId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    'service': string;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    'usageType': string;
    /**
     * 
     * @type {number}
     * @memberof UsageRecord
     */
    'amount': number;
    /**
     * 
     * @type {object}
     * @memberof UsageRecord
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatarUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'gender'?: UserGenderEnum | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birthdate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof User
     */
    'location'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof User
     */
    'social'?: object | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isEmailVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isPhoneVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastLoginAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
}

export const UserGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Other: 'OTHER'
} as const;

export type UserGenderEnum = typeof UserGenderEnum[keyof typeof UserGenderEnum];

/**
 * 
 * @export
 * @interface UserMeGet200Response
 */
export interface UserMeGet200Response {
    /**
     * 
     * @type {string}
     * @memberof UserMeGet200Response
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMeGet200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMeGet200Response
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMeGet200Response
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface UserMePut200Response
 */
export interface UserMePut200Response {
    /**
     * 
     * @type {string}
     * @memberof UserMePut200Response
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMePut200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMePut200Response
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMePut200Response
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface UserMePutRequest
 */
export interface UserMePutRequest {
    /**
     * 
     * @type {string}
     * @memberof UserMePutRequest
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMePutRequest
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Webhook
     */
    'eventTypes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'secret': string;
    /**
     * 
     * @type {boolean}
     * @memberof Webhook
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'lastTriggered'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface WebhookDelivery
 */
export interface WebhookDelivery {
    /**
     * 
     * @type {string}
     * @memberof WebhookDelivery
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookDelivery
     */
    'webhookId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookDelivery
     */
    'event': string;
    /**
     * 
     * @type {number}
     * @memberof WebhookDelivery
     */
    'statusCode'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookDelivery
     */
    'success': boolean;
    /**
     * 
     * @type {object}
     * @memberof WebhookDelivery
     */
    'requestBody'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof WebhookDelivery
     */
    'responseBody'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookDelivery
     */
    'deliveredAt': string;
}
/**
 * 
 * @export
 * @interface WebhooksGet200Response
 */
export interface WebhooksGet200Response {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhooksGet200Response
     */
    'webhooks'?: Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WebhooksPost201Response
 */
export interface WebhooksPost201Response {
    /**
     * 
     * @type {Webhook}
     * @memberof WebhooksPost201Response
     */
    'webhook'?: Webhook;
}
/**
 * 
 * @export
 * @interface WebhooksPostRequest
 */
export interface WebhooksPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksPostRequest
     */
    'url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhooksPostRequest
     */
    'eventTypes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WebhooksWebhookIdDeliveriesGet200Response
 */
export interface WebhooksWebhookIdDeliveriesGet200Response {
    /**
     * 
     * @type {Array<WebhookDelivery>}
     * @memberof WebhooksWebhookIdDeliveriesGet200Response
     */
    'deliveries'?: Array<WebhookDelivery>;
}

/**
 * APIKeyApi - axios parameter creator
 * @export
 */
export const APIKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Revoke/delete API key
         * @param {string} tenantId 
         * @param {string} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyTenantIdApiKeysApiKeyIdDelete: async (tenantId: string, apiKeyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('apikeyTenantIdApiKeysApiKeyIdDelete', 'tenantId', tenantId)
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('apikeyTenantIdApiKeysApiKeyIdDelete', 'apiKeyId', apiKeyId)
            const localVarPath = `/apikey/{tenantId}/api-keys/{apiKeyId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"apiKeyId"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update API key details
         * @param {string} tenantId 
         * @param {string} apiKeyId 
         * @param {ApikeyTenantIdApiKeysApiKeyIdPutRequest} apikeyTenantIdApiKeysApiKeyIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyTenantIdApiKeysApiKeyIdPut: async (tenantId: string, apiKeyId: string, apikeyTenantIdApiKeysApiKeyIdPutRequest: ApikeyTenantIdApiKeysApiKeyIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('apikeyTenantIdApiKeysApiKeyIdPut', 'tenantId', tenantId)
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('apikeyTenantIdApiKeysApiKeyIdPut', 'apiKeyId', apiKeyId)
            // verify required parameter 'apikeyTenantIdApiKeysApiKeyIdPutRequest' is not null or undefined
            assertParamExists('apikeyTenantIdApiKeysApiKeyIdPut', 'apikeyTenantIdApiKeysApiKeyIdPutRequest', apikeyTenantIdApiKeysApiKeyIdPutRequest)
            const localVarPath = `/apikey/{tenantId}/api-keys/{apiKeyId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"apiKeyId"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apikeyTenantIdApiKeysApiKeyIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API keys of tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyTenantIdApiKeysGet: async (tenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('apikeyTenantIdApiKeysGet', 'tenantId', tenantId)
            const localVarPath = `/apikey/{tenantId}/api-keys`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create API key for tenant
         * @param {string} tenantId 
         * @param {ApikeyTenantIdApiKeysPostRequest} apikeyTenantIdApiKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyTenantIdApiKeysPost: async (tenantId: string, apikeyTenantIdApiKeysPostRequest: ApikeyTenantIdApiKeysPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('apikeyTenantIdApiKeysPost', 'tenantId', tenantId)
            // verify required parameter 'apikeyTenantIdApiKeysPostRequest' is not null or undefined
            assertParamExists('apikeyTenantIdApiKeysPost', 'apikeyTenantIdApiKeysPostRequest', apikeyTenantIdApiKeysPostRequest)
            const localVarPath = `/apikey/{tenantId}/api-keys`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apikeyTenantIdApiKeysPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeyApi - functional programming interface
 * @export
 */
export const APIKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Revoke/delete API key
         * @param {string} tenantId 
         * @param {string} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apikeyTenantIdApiKeysApiKeyIdDelete(tenantId: string, apiKeyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apikeyTenantIdApiKeysApiKeyIdDelete(tenantId, apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.apikeyTenantIdApiKeysApiKeyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update API key details
         * @param {string} tenantId 
         * @param {string} apiKeyId 
         * @param {ApikeyTenantIdApiKeysApiKeyIdPutRequest} apikeyTenantIdApiKeysApiKeyIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apikeyTenantIdApiKeysApiKeyIdPut(tenantId: string, apiKeyId: string, apikeyTenantIdApiKeysApiKeyIdPutRequest: ApikeyTenantIdApiKeysApiKeyIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApikeyTenantIdApiKeysPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apikeyTenantIdApiKeysApiKeyIdPut(tenantId, apiKeyId, apikeyTenantIdApiKeysApiKeyIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.apikeyTenantIdApiKeysApiKeyIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List API keys of tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apikeyTenantIdApiKeysGet(tenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApikeyTenantIdApiKeysGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apikeyTenantIdApiKeysGet(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.apikeyTenantIdApiKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create API key for tenant
         * @param {string} tenantId 
         * @param {ApikeyTenantIdApiKeysPostRequest} apikeyTenantIdApiKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apikeyTenantIdApiKeysPost(tenantId: string, apikeyTenantIdApiKeysPostRequest: ApikeyTenantIdApiKeysPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApikeyTenantIdApiKeysPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apikeyTenantIdApiKeysPost(tenantId, apikeyTenantIdApiKeysPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.apikeyTenantIdApiKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIKeyApi - factory interface
 * @export
 */
export const APIKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeyApiFp(configuration)
    return {
        /**
         * 
         * @summary Revoke/delete API key
         * @param {string} tenantId 
         * @param {string} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyTenantIdApiKeysApiKeyIdDelete(tenantId: string, apiKeyId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apikeyTenantIdApiKeysApiKeyIdDelete(tenantId, apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update API key details
         * @param {string} tenantId 
         * @param {string} apiKeyId 
         * @param {ApikeyTenantIdApiKeysApiKeyIdPutRequest} apikeyTenantIdApiKeysApiKeyIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyTenantIdApiKeysApiKeyIdPut(tenantId: string, apiKeyId: string, apikeyTenantIdApiKeysApiKeyIdPutRequest: ApikeyTenantIdApiKeysApiKeyIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApikeyTenantIdApiKeysPost201Response> {
            return localVarFp.apikeyTenantIdApiKeysApiKeyIdPut(tenantId, apiKeyId, apikeyTenantIdApiKeysApiKeyIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API keys of tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyTenantIdApiKeysGet(tenantId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApikeyTenantIdApiKeysGet200Response> {
            return localVarFp.apikeyTenantIdApiKeysGet(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create API key for tenant
         * @param {string} tenantId 
         * @param {ApikeyTenantIdApiKeysPostRequest} apikeyTenantIdApiKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeyTenantIdApiKeysPost(tenantId: string, apikeyTenantIdApiKeysPostRequest: ApikeyTenantIdApiKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApikeyTenantIdApiKeysPost201Response> {
            return localVarFp.apikeyTenantIdApiKeysPost(tenantId, apikeyTenantIdApiKeysPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeyApi - object-oriented interface
 * @export
 * @class APIKeyApi
 * @extends {BaseAPI}
 */
export class APIKeyApi extends BaseAPI {
    /**
     * 
     * @summary Revoke/delete API key
     * @param {string} tenantId 
     * @param {string} apiKeyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public apikeyTenantIdApiKeysApiKeyIdDelete(tenantId: string, apiKeyId: string, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).apikeyTenantIdApiKeysApiKeyIdDelete(tenantId, apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update API key details
     * @param {string} tenantId 
     * @param {string} apiKeyId 
     * @param {ApikeyTenantIdApiKeysApiKeyIdPutRequest} apikeyTenantIdApiKeysApiKeyIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public apikeyTenantIdApiKeysApiKeyIdPut(tenantId: string, apiKeyId: string, apikeyTenantIdApiKeysApiKeyIdPutRequest: ApikeyTenantIdApiKeysApiKeyIdPutRequest, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).apikeyTenantIdApiKeysApiKeyIdPut(tenantId, apiKeyId, apikeyTenantIdApiKeysApiKeyIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API keys of tenant
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public apikeyTenantIdApiKeysGet(tenantId: string, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).apikeyTenantIdApiKeysGet(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create API key for tenant
     * @param {string} tenantId 
     * @param {ApikeyTenantIdApiKeysPostRequest} apikeyTenantIdApiKeysPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public apikeyTenantIdApiKeysPost(tenantId: string, apikeyTenantIdApiKeysPostRequest: ApikeyTenantIdApiKeysPostRequest, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).apikeyTenantIdApiKeysPost(tenantId, apikeyTenantIdApiKeysPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Request password reset
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authForgotPasswordPost: async (authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authForgotPasswordPostRequest' is not null or undefined
            assertParamExists('authForgotPasswordPost', 'authForgotPasswordPostRequest', authForgotPasswordPostRequest)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authForgotPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GitHub OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGithubCallbackGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GitHub OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGithubGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Google OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGoogleCallbackGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Google OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGoogleGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login with email and password
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (authLoginPostRequest: AuthLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginPostRequest' is not null or undefined
            assertParamExists('authLoginPost', 'authLoginPostRequest', authLoginPostRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current authenticated user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (authRegisterPostRequest: AuthRegisterPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRegisterPostRequest' is not null or undefined
            assertParamExists('authRegisterPost', 'authRegisterPostRequest', authRegisterPostRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request email verification
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRequestEmailVerificationPost: async (authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authForgotPasswordPostRequest' is not null or undefined
            assertParamExists('authRequestEmailVerificationPost', 'authForgotPasswordPostRequest', authForgotPasswordPostRequest)
            const localVarPath = `/auth/request-email-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authForgotPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request mobile verification
         * @param {AuthRequestMobileVerificationPostRequest} authRequestMobileVerificationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRequestMobileVerificationPost: async (authRequestMobileVerificationPostRequest: AuthRequestMobileVerificationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRequestMobileVerificationPostRequest' is not null or undefined
            assertParamExists('authRequestMobileVerificationPost', 'authRequestMobileVerificationPostRequest', authRequestMobileVerificationPostRequest)
            const localVarPath = `/auth/request-mobile-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequestMobileVerificationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify email address
         * @param {AuthVerifyEmailPostRequest} authVerifyEmailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmailPost: async (authVerifyEmailPostRequest: AuthVerifyEmailPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authVerifyEmailPostRequest' is not null or undefined
            assertParamExists('authVerifyEmailPost', 'authVerifyEmailPostRequest', authVerifyEmailPostRequest)
            const localVarPath = `/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authVerifyEmailPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify mobile number
         * @param {AuthVerifyMobilePostRequest} authVerifyMobilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyMobilePost: async (authVerifyMobilePostRequest: AuthVerifyMobilePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authVerifyMobilePostRequest' is not null or undefined
            assertParamExists('authVerifyMobilePost', 'authVerifyMobilePostRequest', authVerifyMobilePostRequest)
            const localVarPath = `/auth/verify-mobile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authVerifyMobilePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify registration (OTP)
         * @param {AuthVerifyEmailPostRequest} authVerifyEmailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyRegistrationPost: async (authVerifyEmailPostRequest: AuthVerifyEmailPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authVerifyEmailPostRequest' is not null or undefined
            assertParamExists('authVerifyRegistrationPost', 'authVerifyEmailPostRequest', authVerifyEmailPostRequest)
            const localVarPath = `/auth/verify-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authVerifyEmailPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Request password reset
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authForgotPasswordPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authForgotPasswordPost(authForgotPasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authForgotPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GitHub OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGithubCallbackGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGithubCallbackGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authGithubCallbackGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GitHub OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGithubGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGithubGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authGithubGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Google OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGoogleCallbackGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGoogleCallbackGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authGoogleCallbackGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Google OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGoogleGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGoogleGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authGoogleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login with email and password
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(authLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLogoutPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current authenticated user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegisterPost201ResponseUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegisterPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(authRegisterPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request email verification
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRequestEmailVerificationPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRequestEmailVerificationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRequestEmailVerificationPost(authForgotPasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRequestEmailVerificationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request mobile verification
         * @param {AuthRequestMobileVerificationPostRequest} authRequestMobileVerificationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRequestMobileVerificationPost(authRequestMobileVerificationPostRequest: AuthRequestMobileVerificationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRequestMobileVerificationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRequestMobileVerificationPost(authRequestMobileVerificationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRequestMobileVerificationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify email address
         * @param {AuthVerifyEmailPostRequest} authVerifyEmailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyEmailPost(authVerifyEmailPostRequest: AuthVerifyEmailPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthVerifyEmailPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyEmailPost(authVerifyEmailPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authVerifyEmailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify mobile number
         * @param {AuthVerifyMobilePostRequest} authVerifyMobilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyMobilePost(authVerifyMobilePostRequest: AuthVerifyMobilePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthVerifyMobilePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyMobilePost(authVerifyMobilePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authVerifyMobilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify registration (OTP)
         * @param {AuthVerifyEmailPostRequest} authVerifyEmailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyRegistrationPost(authVerifyEmailPostRequest: AuthVerifyEmailPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthVerifyRegistrationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyRegistrationPost(authVerifyEmailPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authVerifyRegistrationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Request password reset
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authForgotPasswordPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.authForgotPasswordPost(authForgotPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GitHub OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGithubCallbackGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authGithubCallbackGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GitHub OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGithubGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authGithubGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Google OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGoogleCallbackGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authGoogleCallbackGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Google OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGoogleGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authGoogleGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login with email and password
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthLoginPost200Response> {
            return localVarFp.authLoginPost(authLoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<AuthLogoutPost200Response> {
            return localVarFp.authLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current authenticated user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeGet(options?: RawAxiosRequestConfig): AxiosPromise<AuthRegisterPost201ResponseUser> {
            return localVarFp.authMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRegisterPost201Response> {
            return localVarFp.authRegisterPost(authRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request email verification
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRequestEmailVerificationPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRequestEmailVerificationPost200Response> {
            return localVarFp.authRequestEmailVerificationPost(authForgotPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request mobile verification
         * @param {AuthRequestMobileVerificationPostRequest} authRequestMobileVerificationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRequestMobileVerificationPost(authRequestMobileVerificationPostRequest: AuthRequestMobileVerificationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRequestMobileVerificationPost200Response> {
            return localVarFp.authRequestMobileVerificationPost(authRequestMobileVerificationPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify email address
         * @param {AuthVerifyEmailPostRequest} authVerifyEmailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmailPost(authVerifyEmailPostRequest: AuthVerifyEmailPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthVerifyEmailPost200Response> {
            return localVarFp.authVerifyEmailPost(authVerifyEmailPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify mobile number
         * @param {AuthVerifyMobilePostRequest} authVerifyMobilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyMobilePost(authVerifyMobilePostRequest: AuthVerifyMobilePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthVerifyMobilePost200Response> {
            return localVarFp.authVerifyMobilePost(authVerifyMobilePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify registration (OTP)
         * @param {AuthVerifyEmailPostRequest} authVerifyEmailPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyRegistrationPost(authVerifyEmailPostRequest: AuthVerifyEmailPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthVerifyRegistrationPost200Response> {
            return localVarFp.authVerifyRegistrationPost(authVerifyEmailPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Request password reset
     * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authForgotPasswordPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authForgotPasswordPost(authForgotPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GitHub OAuth callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authGithubCallbackGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authGithubCallbackGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GitHub OAuth login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authGithubGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authGithubGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Google OAuth callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authGoogleCallbackGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authGoogleCallbackGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Google OAuth login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authGoogleGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authGoogleGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login with email and password
     * @param {AuthLoginPostRequest} authLoginPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(authLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current authenticated user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMeGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {AuthRegisterPostRequest} authRegisterPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(authRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request email verification
     * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRequestEmailVerificationPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRequestEmailVerificationPost(authForgotPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request mobile verification
     * @param {AuthRequestMobileVerificationPostRequest} authRequestMobileVerificationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRequestMobileVerificationPost(authRequestMobileVerificationPostRequest: AuthRequestMobileVerificationPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRequestMobileVerificationPost(authRequestMobileVerificationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify email address
     * @param {AuthVerifyEmailPostRequest} authVerifyEmailPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyEmailPost(authVerifyEmailPostRequest: AuthVerifyEmailPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyEmailPost(authVerifyEmailPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify mobile number
     * @param {AuthVerifyMobilePostRequest} authVerifyMobilePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyMobilePost(authVerifyMobilePostRequest: AuthVerifyMobilePostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyMobilePost(authVerifyMobilePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify registration (OTP)
     * @param {AuthVerifyEmailPostRequest} authVerifyEmailPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyRegistrationPost(authVerifyEmailPostRequest: AuthVerifyEmailPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyRegistrationPost(authVerifyEmailPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class2FAApi - axios parameter creator
 * @export
 */
export const Class2FAApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Enable two-factor authentication
         * @param {Model2faEnablePostRequest} model2faEnablePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _2faEnablePost: async (model2faEnablePostRequest: Model2faEnablePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model2faEnablePostRequest' is not null or undefined
            assertParamExists('_2faEnablePost', 'model2faEnablePostRequest', model2faEnablePostRequest)
            const localVarPath = `/2fa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model2faEnablePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2FAApi - functional programming interface
 * @export
 */
export const Class2FAApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2FAApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Enable two-factor authentication
         * @param {Model2faEnablePostRequest} model2faEnablePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _2faEnablePost(model2faEnablePostRequest: Model2faEnablePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model2faEnablePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._2faEnablePost(model2faEnablePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2FAApi._2faEnablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class2FAApi - factory interface
 * @export
 */
export const Class2FAApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2FAApiFp(configuration)
    return {
        /**
         * 
         * @summary Enable two-factor authentication
         * @param {Model2faEnablePostRequest} model2faEnablePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _2faEnablePost(model2faEnablePostRequest: Model2faEnablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Model2faEnablePost200Response> {
            return localVarFp._2faEnablePost(model2faEnablePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2FAApi - object-oriented interface
 * @export
 * @class Class2FAApi
 * @extends {BaseAPI}
 */
export class Class2FAApi extends BaseAPI {
    /**
     * 
     * @summary Enable two-factor authentication
     * @param {Model2faEnablePostRequest} model2faEnablePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApi
     */
    public _2faEnablePost(model2faEnablePostRequest: Model2faEnablePostRequest, options?: RawAxiosRequestConfig) {
        return Class2FAApiFp(this.configuration)._2faEnablePost(model2faEnablePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get logs of API usage
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsApiUsageGet: async (tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs/api-usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve audit logs
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsAuditGet: async (tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve user login logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsLoginGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get logs of API usage
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsApiUsageGet(tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsApiUsageGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsApiUsageGet(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.logsApiUsageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve audit logs
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsAuditGet(tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsAuditGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsAuditGet(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.logsAuditGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve user login logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsLoginGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsLoginGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsLoginGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.logsLoginGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get logs of API usage
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsApiUsageGet(tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<LogsApiUsageGet200Response> {
            return localVarFp.logsApiUsageGet(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve audit logs
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsAuditGet(tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<LogsAuditGet200Response> {
            return localVarFp.logsAuditGet(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve user login logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsLoginGet(options?: RawAxiosRequestConfig): AxiosPromise<LogsLoginGet200Response> {
            return localVarFp.logsLoginGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @summary Get logs of API usage
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public logsApiUsageGet(tenantId?: string, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).logsApiUsageGet(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve audit logs
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public logsAuditGet(tenantId?: string, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).logsAuditGet(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve user login logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public logsLoginGet(options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).logsLoginGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Initiate a new payment
         * @param {PaymentInitiatePostRequest} paymentInitiatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentInitiatePost: async (paymentInitiatePostRequest: PaymentInitiatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentInitiatePostRequest' is not null or undefined
            assertParamExists('paymentInitiatePost', 'paymentInitiatePostRequest', paymentInitiatePostRequest)
            const localVarPath = `/payment/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentInitiatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPaymentIdConfirmPost: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('paymentPaymentIdConfirmPost', 'paymentId', paymentId)
            const localVarPath = `/payment/{paymentId}/confirm`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payment status and details
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPaymentIdGet: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('paymentPaymentIdGet', 'paymentId', paymentId)
            const localVarPath = `/payment/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPaymentIdRefundPost: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('paymentPaymentIdRefundPost', 'paymentId', paymentId)
            const localVarPath = `/payment/{paymentId}/refund`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Initiate a new payment
         * @param {PaymentInitiatePostRequest} paymentInitiatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentInitiatePost(paymentInitiatePostRequest: PaymentInitiatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentInitiatePost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentInitiatePost(paymentInitiatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentInitiatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Confirm a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentPaymentIdConfirmPost(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentInitiatePost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentPaymentIdConfirmPost(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentPaymentIdConfirmPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get payment status and details
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentPaymentIdGet(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentInitiatePost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentPaymentIdGet(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentPaymentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentPaymentIdRefundPost(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentInitiatePost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentPaymentIdRefundPost(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentPaymentIdRefundPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Initiate a new payment
         * @param {PaymentInitiatePostRequest} paymentInitiatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentInitiatePost(paymentInitiatePostRequest: PaymentInitiatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentInitiatePost201Response> {
            return localVarFp.paymentInitiatePost(paymentInitiatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPaymentIdConfirmPost(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentInitiatePost201Response> {
            return localVarFp.paymentPaymentIdConfirmPost(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payment status and details
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPaymentIdGet(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentInitiatePost201Response> {
            return localVarFp.paymentPaymentIdGet(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPaymentIdRefundPost(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentInitiatePost201Response> {
            return localVarFp.paymentPaymentIdRefundPost(paymentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @summary Initiate a new payment
     * @param {PaymentInitiatePostRequest} paymentInitiatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentInitiatePost(paymentInitiatePostRequest: PaymentInitiatePostRequest, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentInitiatePost(paymentInitiatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm a payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentPaymentIdConfirmPost(paymentId: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentPaymentIdConfirmPost(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payment status and details
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentPaymentIdGet(paymentId: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentPaymentIdGet(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refund a payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentPaymentIdRefundPost(paymentId: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentPaymentIdRefundPost(paymentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductPostRequest} productPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPost: async (productPostRequest: ProductPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productPostRequest' is not null or undefined
            assertParamExists('productPost', 'productPostRequest', productPostRequest)
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productProductIdDelete: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productProductIdDelete', 'productId', productId)
            const localVarPath = `/product/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product details
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productProductIdGet: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productProductIdGet', 'productId', productId)
            const localVarPath = `/product/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a product
         * @param {string} productId 
         * @param {ProductProductIdPutRequest} productProductIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productProductIdPut: async (productId: string, productProductIdPutRequest: ProductProductIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productProductIdPut', 'productId', productId)
            // verify required parameter 'productProductIdPutRequest' is not null or undefined
            assertParamExists('productProductIdPut', 'productProductIdPutRequest', productProductIdPutRequest)
            const localVarPath = `/product/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productProductIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductPostRequest} productPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productPost(productPostRequest: ProductPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productPost(productPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productProductIdDelete(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productProductIdDelete(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productProductIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get product details
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productProductIdGet(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productProductIdGet(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productProductIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a product
         * @param {string} productId 
         * @param {ProductProductIdPutRequest} productProductIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productProductIdPut(productId: string, productProductIdPutRequest: ProductProductIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productProductIdPut(productId, productProductIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productProductIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @summary List all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGet(options?: RawAxiosRequestConfig): AxiosPromise<ProductGet200Response> {
            return localVarFp.productGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductPostRequest} productPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPost(productPostRequest: ProductPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductPost201Response> {
            return localVarFp.productPost(productPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productProductIdDelete(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productProductIdDelete(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product details
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productProductIdGet(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductPost201Response> {
            return localVarFp.productProductIdGet(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a product
         * @param {string} productId 
         * @param {ProductProductIdPutRequest} productProductIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productProductIdPut(productId: string, productProductIdPutRequest: ProductProductIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductPost201Response> {
            return localVarFp.productProductIdPut(productId, productProductIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary List all products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productGet(options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new product
     * @param {ProductPostRequest} productPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productPost(productPostRequest: ProductPostRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productPost(productPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a product
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productProductIdDelete(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productProductIdDelete(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product details
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productProductIdGet(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productProductIdGet(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a product
     * @param {string} productId 
     * @param {ProductProductIdPutRequest} productProductIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productProductIdPut(productId: string, productProductIdPutRequest: ProductProductIdPutRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productProductIdPut(productId, productProductIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RBACApi - axios parameter creator
 * @export
 */
export const RBACApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacRolesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new role
         * @param {RbacRolesPostRequest} rbacRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacRolesPost: async (rbacRolesPostRequest: RbacRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rbacRolesPostRequest' is not null or undefined
            assertParamExists('rbacRolesPost', 'rbacRolesPostRequest', rbacRolesPostRequest)
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rbacRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacRolesRoleIdDelete: async (roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rbacRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/rbac/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a role
         * @param {string} roleId 
         * @param {RbacRolesRoleIdPutRequest} rbacRolesRoleIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacRolesRoleIdPut: async (roleId: string, rbacRolesRoleIdPutRequest: RbacRolesRoleIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rbacRolesRoleIdPut', 'roleId', roleId)
            // verify required parameter 'rbacRolesRoleIdPutRequest' is not null or undefined
            assertParamExists('rbacRolesRoleIdPut', 'rbacRolesRoleIdPutRequest', rbacRolesRoleIdPutRequest)
            const localVarPath = `/rbac/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rbacRolesRoleIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RBACApi - functional programming interface
 * @export
 */
export const RBACApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RBACApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacRolesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacRolesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacRolesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RBACApi.rbacRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new role
         * @param {RbacRolesPostRequest} rbacRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacRolesPost(rbacRolesPostRequest: RbacRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacRolesPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacRolesPost(rbacRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RBACApi.rbacRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacRolesRoleIdDelete(roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacRolesRoleIdDelete(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RBACApi.rbacRolesRoleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a role
         * @param {string} roleId 
         * @param {RbacRolesRoleIdPutRequest} rbacRolesRoleIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacRolesRoleIdPut(roleId: string, rbacRolesRoleIdPutRequest: RbacRolesRoleIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacRolesPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacRolesRoleIdPut(roleId, rbacRolesRoleIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RBACApi.rbacRolesRoleIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RBACApi - factory interface
 * @export
 */
export const RBACApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RBACApiFp(configuration)
    return {
        /**
         * 
         * @summary List all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacRolesGet(options?: RawAxiosRequestConfig): AxiosPromise<RbacRolesGet200Response> {
            return localVarFp.rbacRolesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new role
         * @param {RbacRolesPostRequest} rbacRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacRolesPost(rbacRolesPostRequest: RbacRolesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<RbacRolesPost201Response> {
            return localVarFp.rbacRolesPost(rbacRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacRolesRoleIdDelete(roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rbacRolesRoleIdDelete(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a role
         * @param {string} roleId 
         * @param {RbacRolesRoleIdPutRequest} rbacRolesRoleIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacRolesRoleIdPut(roleId: string, rbacRolesRoleIdPutRequest: RbacRolesRoleIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<RbacRolesPost201Response> {
            return localVarFp.rbacRolesRoleIdPut(roleId, rbacRolesRoleIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RBACApi - object-oriented interface
 * @export
 * @class RBACApi
 * @extends {BaseAPI}
 */
export class RBACApi extends BaseAPI {
    /**
     * 
     * @summary List all roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public rbacRolesGet(options?: RawAxiosRequestConfig) {
        return RBACApiFp(this.configuration).rbacRolesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new role
     * @param {RbacRolesPostRequest} rbacRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public rbacRolesPost(rbacRolesPostRequest: RbacRolesPostRequest, options?: RawAxiosRequestConfig) {
        return RBACApiFp(this.configuration).rbacRolesPost(rbacRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a role
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public rbacRolesRoleIdDelete(roleId: string, options?: RawAxiosRequestConfig) {
        return RBACApiFp(this.configuration).rbacRolesRoleIdDelete(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a role
     * @param {string} roleId 
     * @param {RbacRolesRoleIdPutRequest} rbacRolesRoleIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public rbacRolesRoleIdPut(roleId: string, rbacRolesRoleIdPutRequest: RbacRolesRoleIdPutRequest, options?: RawAxiosRequestConfig) {
        return RBACApiFp(this.configuration).rbacRolesRoleIdPut(roleId, rbacRolesRoleIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReservationApi - axios parameter creator
 * @export
 */
export const ReservationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List reservations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reservation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new reservation
         * @param {ReservationPostRequest} reservationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationPost: async (reservationPostRequest: ReservationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationPostRequest' is not null or undefined
            assertParamExists('reservationPost', 'reservationPostRequest', reservationPostRequest)
            const localVarPath = `/reservation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a reservation
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationReservationIdDelete: async (reservationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('reservationReservationIdDelete', 'reservationId', reservationId)
            const localVarPath = `/reservation/{reservationId}`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get reservation details
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationReservationIdGet: async (reservationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('reservationReservationIdGet', 'reservationId', reservationId)
            const localVarPath = `/reservation/{reservationId}`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a reservation
         * @param {string} reservationId 
         * @param {ReservationReservationIdPutRequest} reservationReservationIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationReservationIdPut: async (reservationId: string, reservationReservationIdPutRequest: ReservationReservationIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('reservationReservationIdPut', 'reservationId', reservationId)
            // verify required parameter 'reservationReservationIdPutRequest' is not null or undefined
            assertParamExists('reservationReservationIdPut', 'reservationReservationIdPutRequest', reservationReservationIdPutRequest)
            const localVarPath = `/reservation/{reservationId}`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservationReservationIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReservationApi - functional programming interface
 * @export
 */
export const ReservationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReservationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List reservations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.reservationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new reservation
         * @param {ReservationPostRequest} reservationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationPost(reservationPostRequest: ReservationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationPost(reservationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.reservationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a reservation
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationReservationIdDelete(reservationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationReservationIdDelete(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.reservationReservationIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get reservation details
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationReservationIdGet(reservationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationReservationIdGet(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.reservationReservationIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a reservation
         * @param {string} reservationId 
         * @param {ReservationReservationIdPutRequest} reservationReservationIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationReservationIdPut(reservationId: string, reservationReservationIdPutRequest: ReservationReservationIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationReservationIdPut(reservationId, reservationReservationIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationApi.reservationReservationIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReservationApi - factory interface
 * @export
 */
export const ReservationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReservationApiFp(configuration)
    return {
        /**
         * 
         * @summary List reservations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationGet(options?: RawAxiosRequestConfig): AxiosPromise<ReservationGet200Response> {
            return localVarFp.reservationGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new reservation
         * @param {ReservationPostRequest} reservationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationPost(reservationPostRequest: ReservationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReservationPost201Response> {
            return localVarFp.reservationPost(reservationPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a reservation
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationReservationIdDelete(reservationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reservationReservationIdDelete(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get reservation details
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationReservationIdGet(reservationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReservationPost201Response> {
            return localVarFp.reservationReservationIdGet(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a reservation
         * @param {string} reservationId 
         * @param {ReservationReservationIdPutRequest} reservationReservationIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationReservationIdPut(reservationId: string, reservationReservationIdPutRequest: ReservationReservationIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReservationPost201Response> {
            return localVarFp.reservationReservationIdPut(reservationId, reservationReservationIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReservationApi - object-oriented interface
 * @export
 * @class ReservationApi
 * @extends {BaseAPI}
 */
export class ReservationApi extends BaseAPI {
    /**
     * 
     * @summary List reservations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationApi
     */
    public reservationGet(options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).reservationGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new reservation
     * @param {ReservationPostRequest} reservationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationApi
     */
    public reservationPost(reservationPostRequest: ReservationPostRequest, options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).reservationPost(reservationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a reservation
     * @param {string} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationApi
     */
    public reservationReservationIdDelete(reservationId: string, options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).reservationReservationIdDelete(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get reservation details
     * @param {string} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationApi
     */
    public reservationReservationIdGet(reservationId: string, options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).reservationReservationIdGet(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a reservation
     * @param {string} reservationId 
     * @param {ReservationReservationIdPutRequest} reservationReservationIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationApi
     */
    public reservationReservationIdPut(reservationId: string, reservationReservationIdPutRequest: ReservationReservationIdPutRequest, options?: RawAxiosRequestConfig) {
        return ReservationApiFp(this.configuration).reservationReservationIdPut(reservationId, reservationReservationIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List active user sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List active user sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.sessionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary List active user sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGet(options?: RawAxiosRequestConfig): AxiosPromise<SessionsGet200Response> {
            return localVarFp.sessionsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary List active user sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsGet(options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get invoices related to tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTenantIdInvoicesGet: async (tenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('subscriptionTenantIdInvoicesGet', 'tenantId', tenantId)
            const localVarPath = `/subscription/{tenantId}/invoices`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tenant subscriptions
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTenantIdSubscriptionsGet: async (tenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('subscriptionTenantIdSubscriptionsGet', 'tenantId', tenantId)
            const localVarPath = `/subscription/{tenantId}/subscriptions`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get API and service usage records for tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTenantIdUsageGet: async (tenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('subscriptionTenantIdUsageGet', 'tenantId', tenantId)
            const localVarPath = `/subscription/{tenantId}/usage`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get invoices related to tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionTenantIdInvoicesGet(tenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionTenantIdInvoicesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionTenantIdInvoicesGet(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.subscriptionTenantIdInvoicesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List tenant subscriptions
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionTenantIdSubscriptionsGet(tenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionTenantIdSubscriptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionTenantIdSubscriptionsGet(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.subscriptionTenantIdSubscriptionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get API and service usage records for tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionTenantIdUsageGet(tenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionTenantIdUsageGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionTenantIdUsageGet(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.subscriptionTenantIdUsageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * 
         * @summary Get invoices related to tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTenantIdInvoicesGet(tenantId: string, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionTenantIdInvoicesGet200Response> {
            return localVarFp.subscriptionTenantIdInvoicesGet(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tenant subscriptions
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTenantIdSubscriptionsGet(tenantId: string, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionTenantIdSubscriptionsGet200Response> {
            return localVarFp.subscriptionTenantIdSubscriptionsGet(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get API and service usage records for tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTenantIdUsageGet(tenantId: string, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionTenantIdUsageGet200Response> {
            return localVarFp.subscriptionTenantIdUsageGet(tenantId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * 
     * @summary Get invoices related to tenant
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public subscriptionTenantIdInvoicesGet(tenantId: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).subscriptionTenantIdInvoicesGet(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tenant subscriptions
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public subscriptionTenantIdSubscriptionsGet(tenantId: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).subscriptionTenantIdSubscriptionsGet(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get API and service usage records for tenant
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public subscriptionTenantIdUsageGet(tenantId: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).subscriptionTenantIdUsageGet(tenantId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TenantApi - axios parameter creator
 * @export
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all tenants user belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new tenant (organization)
         * @param {TenantPostRequest} tenantPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantPost: async (tenantPostRequest: TenantPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantPostRequest' is not null or undefined
            assertParamExists('tenantPost', 'tenantPostRequest', tenantPostRequest)
            const localVarPath = `/tenant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantTenantIdDelete: async (tenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantTenantIdDelete', 'tenantId', tenantId)
            const localVarPath = `/tenant/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tenant details
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantTenantIdGet: async (tenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantTenantIdGet', 'tenantId', tenantId)
            const localVarPath = `/tenant/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update tenant information
         * @param {string} tenantId 
         * @param {TenantTenantIdPutRequest} tenantTenantIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantTenantIdPut: async (tenantId: string, tenantTenantIdPutRequest: TenantTenantIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantTenantIdPut', 'tenantId', tenantId)
            // verify required parameter 'tenantTenantIdPutRequest' is not null or undefined
            assertParamExists('tenantTenantIdPut', 'tenantTenantIdPutRequest', tenantTenantIdPutRequest)
            const localVarPath = `/tenant/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantTenantIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 * @export
 */
export const TenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all tenants user belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.tenantGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new tenant (organization)
         * @param {TenantPostRequest} tenantPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantPost(tenantPostRequest: TenantPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantPost(tenantPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.tenantPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantTenantIdDelete(tenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantTenantIdDelete(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.tenantTenantIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tenant details
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantTenantIdGet(tenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantTenantIdGet(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.tenantTenantIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update tenant information
         * @param {string} tenantId 
         * @param {TenantTenantIdPutRequest} tenantTenantIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantTenantIdPut(tenantId: string, tenantTenantIdPutRequest: TenantTenantIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantTenantIdPut(tenantId, tenantTenantIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.tenantTenantIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TenantApi - factory interface
 * @export
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantApiFp(configuration)
    return {
        /**
         * 
         * @summary List all tenants user belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantGet(options?: RawAxiosRequestConfig): AxiosPromise<TenantGet200Response> {
            return localVarFp.tenantGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new tenant (organization)
         * @param {TenantPostRequest} tenantPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantPost(tenantPostRequest: TenantPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TenantPost201Response> {
            return localVarFp.tenantPost(tenantPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tenant
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantTenantIdDelete(tenantId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tenantTenantIdDelete(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tenant details
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantTenantIdGet(tenantId: string, options?: RawAxiosRequestConfig): AxiosPromise<TenantPost201Response> {
            return localVarFp.tenantTenantIdGet(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update tenant information
         * @param {string} tenantId 
         * @param {TenantTenantIdPutRequest} tenantTenantIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantTenantIdPut(tenantId: string, tenantTenantIdPutRequest: TenantTenantIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<TenantPost201Response> {
            return localVarFp.tenantTenantIdPut(tenantId, tenantTenantIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
export class TenantApi extends BaseAPI {
    /**
     * 
     * @summary List all tenants user belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public tenantGet(options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).tenantGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new tenant (organization)
     * @param {TenantPostRequest} tenantPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public tenantPost(tenantPostRequest: TenantPostRequest, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).tenantPost(tenantPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tenant
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public tenantTenantIdDelete(tenantId: string, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).tenantTenantIdDelete(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tenant details
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public tenantTenantIdGet(tenantId: string, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).tenantTenantIdGet(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update tenant information
     * @param {string} tenantId 
     * @param {TenantTenantIdPutRequest} tenantTenantIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public tenantTenantIdPut(tenantId: string, tenantTenantIdPutRequest: TenantTenantIdPutRequest, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).tenantTenantIdPut(tenantId, tenantTenantIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update current user profile
         * @param {UserMePutRequest} userMePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMePut: async (userMePutRequest: UserMePutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userMePutRequest' is not null or undefined
            assertParamExists('userMePut', 'userMePutRequest', userMePutRequest)
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userMePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userMeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update current user profile
         * @param {UserMePutRequest} userMePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMePut(userMePutRequest: UserMePutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMePut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMePut(userMePutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userMePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userMeDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeGet(options?: RawAxiosRequestConfig): AxiosPromise<UserMeGet200Response> {
            return localVarFp.userMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update current user profile
         * @param {UserMePutRequest} userMePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMePut(userMePutRequest: UserMePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserMePut200Response> {
            return localVarFp.userMePut(userMePutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Delete current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMeDelete(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userMeDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update current user profile
     * @param {UserMePutRequest} userMePutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMePut(userMePutRequest: UserMePutRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userMePut(userMePutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all webhooks for tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new webhook
         * @param {WebhooksPostRequest} webhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost: async (webhooksPostRequest: WebhooksPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhooksPostRequest' is not null or undefined
            assertParamExists('webhooksPost', 'webhooksPostRequest', webhooksPostRequest)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhooksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIdDelete: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksWebhookIdDelete', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View webhook delivery attempts
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIdDeliveriesGet: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksWebhookIdDeliveriesGet', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}/deliveries`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update webhook details
         * @param {string} webhookId 
         * @param {WebhooksPostRequest} webhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIdPut: async (webhookId: string, webhooksPostRequest: WebhooksPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksWebhookIdPut', 'webhookId', webhookId)
            // verify required parameter 'webhooksPostRequest' is not null or undefined
            assertParamExists('webhooksWebhookIdPut', 'webhooksPostRequest', webhooksPostRequest)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhooksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all webhooks for tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhooksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new webhook
         * @param {WebhooksPostRequest} webhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksPost(webhooksPostRequest: WebhooksPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksPost(webhooksPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhooksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksWebhookIdDelete(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksWebhookIdDelete(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhooksWebhookIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary View webhook delivery attempts
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksWebhookIdDeliveriesGet(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksWebhookIdDeliveriesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksWebhookIdDeliveriesGet(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhooksWebhookIdDeliveriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update webhook details
         * @param {string} webhookId 
         * @param {WebhooksPostRequest} webhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksWebhookIdPut(webhookId: string, webhooksPostRequest: WebhooksPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksWebhookIdPut(webhookId, webhooksPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhooksWebhookIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary List all webhooks for tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(options?: RawAxiosRequestConfig): AxiosPromise<WebhooksGet200Response> {
            return localVarFp.webhooksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new webhook
         * @param {WebhooksPostRequest} webhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(webhooksPostRequest: WebhooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksPost201Response> {
            return localVarFp.webhooksPost(webhooksPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIdDelete(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksWebhookIdDelete(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View webhook delivery attempts
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIdDeliveriesGet(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksWebhookIdDeliveriesGet200Response> {
            return localVarFp.webhooksWebhookIdDeliveriesGet(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update webhook details
         * @param {string} webhookId 
         * @param {WebhooksPostRequest} webhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIdPut(webhookId: string, webhooksPostRequest: WebhooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksPost201Response> {
            return localVarFp.webhooksWebhookIdPut(webhookId, webhooksPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @summary List all webhooks for tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhooksGet(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhooksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new webhook
     * @param {WebhooksPostRequest} webhooksPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhooksPost(webhooksPostRequest: WebhooksPostRequest, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhooksPost(webhooksPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a webhook
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhooksWebhookIdDelete(webhookId: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhooksWebhookIdDelete(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View webhook delivery attempts
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhooksWebhookIdDeliveriesGet(webhookId: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhooksWebhookIdDeliveriesGet(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update webhook details
     * @param {string} webhookId 
     * @param {WebhooksPostRequest} webhooksPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhooksWebhookIdPut(webhookId: string, webhooksPostRequest: WebhooksPostRequest, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhooksWebhookIdPut(webhookId, webhooksPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



